[腾讯校招笔试真题_C++工程师、golang工程师_牛客网 (nowcoder.com)](https://www.nowcoder.com/exam/test/30545524/summary?pid=30545524&examPageSource=Company&testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fcompany%3FcurrentTab%3Dhostest%26jobId%3D100%26selectStatus%3D0&testclass=软件开发)

## 1 朋友圈(后端开发卷)

并查集，可学

使用并查集（Union Find）算法可以解决这个问题。我们可以将每对关系中的两个用户合并到同一个圈子中，最后计算每个圈子的大小，即圈子内的最多人数。

```cpp
#include <iostream>
#include <vector>

using namespace std;

// 并查集数据结构
class UnionFind {
  private:
    vector<int> parent; // 存储每个节点的父节点
    vector<int> size;   // 存储每个节点所在集合的大小

  public:
    UnionFind(int n) {
        parent.resize(n + 1);
        size.resize(n + 1);

        // 初始化每个节点为独立的集合，大小为1
        for (int i = 1; i <= n; i++) {
            // 初始状态下，每个元素都是一个独立的集合，代表元素就是它自己。
            // 每个元素存储其父节点的索引，根节点的父节点指向自身
            parent[i] = i; 
            // 每个集合只有节点自己，所以大小为1
            size[i] = 1;
        }
    }

    // 查找节点所属的集合
    int find(int x) {
        if (x != parent[x]) {
            // 这里说明x不是根节点，因为根结点的父节点指向自身
            // 递归查找，直到找到根节点
            parent[x] = find(parent[x]);
        }
        // 找到了根节点，根节点代表了所属的集合
        return parent[x];
    }

    // 合并两个集合
    void merge(int x, int y) {
        // 找到x和y分别所属的根节点
        int rootX = find(x);
        int rootY = find(y);

        if (rootX != rootY) {
            // 将较小的集合合并到较大的集合中
            if (size[rootX] < size[rootY]) {
                // 把根节点的根节点改了，也就是改了其所属的集合
                parent[rootX] = rootY;
                size[rootY] += size[rootX];
            } else {
                parent[rootY] = rootX;
                size[rootX] += size[rootY];
            }
        }
    }

    // 获取最大的集合大小
    int getMaxSize() {
        int maxSize = 0;
        for (int i = 1; i < size.size(); i++) {
            if (size[i] > maxSize) {
                maxSize = size[i];
            }
        }
        return maxSize;
    }
};

int main() {
    int T;
    cin >> T;

    while (T--) {
        int n;
        cin >> n;

        UnionFind uf(1e5); // 创建并查集，初始共有105个用户

        while (n--) {
            int x, y;
            cin >> x >> y;

            // 合并两个用户所在的圈子
            uf.merge(x, y);
        }

        // 获取最大的圈子大小
        int maxSize = uf.getMaxSize();
        cout << maxSize << endl;
    }

    return 0;
}

```



## 4 队列操作(后端开发卷)

也是简单题

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    int T;
    cin>>T;
    while(T--){
        int Q;
        cin>>Q;
        
        queue<int> que;
        while(Q--){
            string operation;
            cin>>operation;
			// 就是一个一个读操作，如果这个操作需要数字，就再cin一个int
            if(operation=="PUSH"){
                int val;
                cin>>val;
                que.push(val);
            }
            else if(operation=="TOP"){
                if(!que.empty()){
                    cout<<que.front()<<endl;
                }
                else{
                    cout<<-1<<endl;
                }
            }
            else if(operation=="POP"){
                if(!que.empty()){
                    que.pop();
                }
                else{
                    cout<<-1<<endl;
                }
            }
            else if(operation=="SIZE"){
                cout<<que.size()<<endl;
            }
            else if(operation=="CLEAR"){
                while(!que.empty()){
                    que.pop();
                }
            }
        }
    }
    return 0;
}
// 64 位输出请用 printf("%lld")
```

